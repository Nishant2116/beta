from heapq import heappop, heappush

def prim(graph):
    # Select a random starting node
    start_node = list(graph.keys())[0]
    visited = set([start_node])
    minimum_spanning_tree = []
    heap = []

    # Add the edges of the start node to the heap
    for neighbor, weight in graph[start_node]:
        heappush(heap, (weight, start_node, neighbor))

    while heap:
        # Pop the edge with the minimum weight
        weight, source, destination = heappop(heap)

        if destination not in visited:
            # Add the edge to the minimum spanning tree
            minimum_spanning_tree.append((source, destination, weight))
            visited.add(destination)

            # Add the edges of the destination node to the heap
            for neighbor, weight in graph[destination]:
                heappush(heap, (weight, destination, neighbor))

    return minimum_spanning_tree

# Sample input graph
graph = {
    'A': [('B', 3), ('C', 1)],
    'B': [('A', 3), ('C', 7), ('D', 5)],
    'C': [('A', 1), ('B', 7), ('D', 2)],
    'D': [('B', 5), ('C', 2)]
}

minimum_spanning_tree = prim(graph)
print("Minimum Spanning Tree:\n")
for edge in minimum_spanning_tree:
    print(f"Edge: {edge[0]} -- {edge[1]} (Weight: {edge[2]})")